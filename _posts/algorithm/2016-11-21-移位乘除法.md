---
layout: post
title:  "移位实现乘除法"
categories: algorithm
tags: algorithm
---

Source Link: http://blog.csdn.net/limingshandian/article/details/7888799

移位实现的乘除法比直接乘除的效率高很多。

用移位实现乘除法运算
　　a=a*4;
　　b=b/4;
　　可以改为：
　　a=a<<2;
　　b=b>>2;
　　说明：
　　除2 = 右移1位 乘2 = 左移1位
　　除4 = 右移2位 乘4 = 左移2位
　　除8 = 右移3位 乘8 = 左移3位
　　... ...
　　通常如果需要乘以或除以2的n次方，都可以用移位的方法代替。
　　大部分的C编译器,用移位的方法得到代码比调用乘除法子程序生成的代码效率高。
　　实际上，只要是乘以或除以一个整数，均可以用移位的方法得到结果，如：
　　a=a*9
　　分析a*9可以拆分成a*(8+1)即a*8+a*1, 因此可以改为： a=(a<<3)+a
　　a=a*7
　　分析a*7可以拆分成a*(8-1)即a*8-a*1, 因此可以改为： a=(a<<3)-a
　　关于除法读者可以类推, 此略.

一个自己曾经忽视的东西，那就是C/C++中的移位操作容易出错的情况。
1. 什么样的数据类型可以直接移位
char、short、int、long、unsigned char、unsigned short、unsigned int、unsigned long都可以进行移位操作，而double、float、bool、long double则不可以进行移位操作。

2. 有符号数据类型的移位操作
对于char、short、int、long这些有符号的数据类型：
    对负数进行左移：符号位始终为1，其他位左移
    对正数进行左移：所有位左移，即 <<，可能会变成负数
    对负数进行右移：取绝对值，然后右移，再取相反数
    对正数进行右移：所有位右移，即 >>

3. 无符号数据类型的移位操作
对于unsigned char、unsigned short、unsigned int、unsigned long这些无符号数据类型：

没有特殊要说明的，使用<< 和 >> 操作符就OK了
8086 中存在逻辑移位、算术移位，而C/C++中的移位似乎既不是逻辑移位，也不是算术移位。
比如-1，我们若对它右移1位，C的结果仍旧是-1，事实上无论右移多少位始终是-1，逻辑移位得到的结果（8位表示）应该是-128，所以这点要注意
